<html>
<head>
  <title>438. Find All Anagrams in a String</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (en-US, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="8666"/>
<h1>438. Find All Anagrams in a String</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>Created:</b></td><td><i>3/13/2017 9:51 PM</i></td></tr>
<tr><td><b>Updated:</b></td><td><i>3/14/2017 12:27 AM</i></td></tr>
<tr><td><b>Tags:</b></td><td><i>leetcode tag</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description">https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description</a></div><div><br/></div><div><a href="https://discuss.leetcode.com/topic/68976/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem">Sliding Window algorithm template to solve all the Leetcode substring search problem.</a></div><div><br/></div><div><a href="https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems">Here is a 10-line template that can solve most 'substring' problems</a></div><div><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Input:</div><div>s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</div><div><br/></div><div>Output:</div><div>[0, 6]</div><div><br/></div><div>Explanation:</div><div>The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</div><div>The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</div></div><div><br/></div><div>two pointer维持window，前面的负责减，后面加。是可能出现负数的</div><div><br/></div><div>time limit</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class Solution {</div><div>    public List&lt;Integer&gt; findAnagrams(String s, String p) {</div><div><br/></div><div>        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</div><div>        for (int i = 0; i &lt; p.length(); i++) {</div><div>            char c = p.charAt(i);</div><div>            Integer val = map.get(c);</div><div>            if (val == null) {</div><div>                map.put(c, 1);</div><div>            } else {</div><div>                map.put(c, val + 1);</div><div>            }</div><div>        }</div><div>        // System.out.println(map);</div><div>        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div>        for (int i = 0 ; i &lt;= s.length() - p.length(); i++) {</div><div>            HashMap&lt;Character, Integer&gt; newMap = (HashMap&lt;Character, Integer&gt;)map.clone();</div><div>            // System.out.println(newMap);</div><div>            for (int j = i; j &lt; i + p.length(); j++) {</div><div>                char c = s.charAt(j);</div><div>                Integer val = newMap.get(c);</div><div>                if (val == null) {</div><div>                    continue;</div><div>                } else {</div><div>                    if (val == 1) {</div><div>                        newMap.remove(c);   </div><div>                    } else {</div><div>                        newMap.put(c, val - 1);</div><div>                    }</div><div>                }</div><div>            }</div><div>            if (newMap.size() == 0) {</div><div>                list.add(i);</div><div>            }</div><div>        }</div><div>        return list;</div><div><br/></div><div><br/></div><div>    }</div><div>}</div></div><div><br/></div><div>sliding windows</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class Solution {</div><div>    public List&lt;Integer&gt; findAnagrams(String s, String p) {</div><div>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div>    if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;</div><div><br/></div><div>    <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">int[] hash = new int[256]</span>; //character hash</div><div><br/></div><div>    //record each character in p to hash</div><div>    for (char c : p.toCharArray()) {</div><div>        hash[c]++;</div><div>    }</div><div>    //two points, initialize count to p's length</div><div>    int left = 0, right = 0, count = p.length();</div><div><br/></div><div>    while (right &lt; s.length()) {</div><div>        //move right everytime, if the character exists in p's hash, decrease the count</div><div>        //current hash value &gt;= 1 means the character is existing in p</div><div>        if (hash[s.charAt(right)] &gt;= 1) {</div><div>            count--;</div><div>        }</div><div>        hash[s.charAt(right)]--;</div><div>        right++;</div><div><br/></div><div>        //when the count is down to 0, means we found the right anagram</div><div>        //then add window's left to result list</div><div>        if (count == 0) {</div><div>            list.add(left);</div><div>        }</div><div>        //if we find the window's size equals to p, then we have to move left (narrow the window) to find the new match window</div><div>        //++ to reset the hash because we kicked out the left</div><div>        //only increase the count if the character is in p</div><div>        //the count &gt;= 0 indicate it was original in the hash, cuz it won't go below 0</div><div>        if (right - left == p.length() ) {</div><div><br/></div><div>            if (hash[s.charAt(left)] &gt;= 0) {</div><div>                count++;</div><div>            }</div><div>            hash[s.charAt(left)]++;</div><div>            left++;</div><div><br/></div><div>        }</div><div><br/></div><div><br/></div><div>    }</div><div>        return list;</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div>visialization</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class Solution {</div><div>    public List&lt;Integer&gt; findAnagrams(String s, String p) {</div><div>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div>    if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;</div><div><br/></div><div>    // int[] hash = new int[256]; //character hash</div><div>    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</div><div>    for (int i = 0; i &lt; p.length(); i++) {</div><div>        char c = p.charAt(i);</div><div>        Integer val = map.get(c);</div><div>        if (val == null) {</div><div>            map.put(c, 1);</div><div>        } else {</div><div>            map.put(c, val + 1);</div><div>        }</div><div>    }</div><div><br/></div><div>    //two points, initialize count to p's length</div><div>    int left = 0, right = 0, count = p.length();</div><div><br/></div><div>    while (right &lt; s.length()) {</div><div>        //move right everytime, if the character exists in p's hash, decrease the count</div><div>        //current hash value &gt;= 1 means the character is existing in p</div><div>        Integer val = map.get(s.charAt(right));</div><div>        if (val != null) {</div><div>            if (val &gt;= 1) {</div><div>                count--;</div><div>            }</div><div>            map.put(s.charAt(right), val - 1);           </div><div>        }</div><div><br/></div><div>        // hash[s.charAt(right)]--;</div><div>        right++;</div><div><br/></div><div>        //when the count is down to 0, means we found the right anagram</div><div>        //then add window's left to result list</div><div>        if (count == 0) {</div><div>            list.add(left);</div><div>        }</div><div><br/></div><div>        // System.out.println(&quot;left:&quot; + left);</div><div>        // System.out.println(&quot;right:&quot; + right);</div><div>        // System.out.println(&quot;count:&quot; + count);</div><div>        System.out.println(map);</div><div><br/></div><div><br/></div><div>        //if we find the window's size equals to p, then we have to move left (narrow the window) to find the new match window</div><div>        //++ to reset the hash because we kicked out the left</div><div>        //only increase the count if the character is in p</div><div>        //the count &gt;= 0 indicate it was original in the hash, cuz it won't go below 0</div><div>        if (right - left == p.length() ) {</div><div>            Integer val2 = map.get(s.charAt(left));</div><div>            if(val2 != null) {</div><div>                <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">if (val2 &gt;= 0) {</span></div><div>                    count++;</div><div>                }</div><div>                map.put(s.charAt(left), val2 + 1);</div><div>            }</div><div><br/></div><div>            // hash[s.charAt(left)]++;</div><div>            left++;</div><div><br/></div><div>        }</div><div>        System.out.println(map);</div><div>        System.out.println();</div><div><br/></div><div>    }</div><div>        return list;</div><div>    }</div><div>}</div></div><div><br/></div></span>
</div></body></html> 