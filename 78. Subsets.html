<html>
<head>
  <title>78. Subsets</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (en-US, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="4946"/>
<h1>78. Subsets</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>Created:</b></td><td><i>6/19/2016 3:06 AM</i></td></tr>
<tr><td><b>Updated:</b></td><td><i>3/15/2017 8:45 PM</i></td></tr>
<tr><td><b>Tags:</b></td><td><i>*, Arrary, Backtracking, Bit Manipulation, leetcode tag, Medium</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></div><div><br/></div><div>这个太牛逼了</div><div><a href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning">A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)</a></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>backtrack</b></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {</div><div>    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div>    <b>Arrays.sort(nums);</b></div><div>    backtrack(list, new ArrayList&lt;&gt;(), nums, 0);</div><div>    return list;</div><div>}</div><div><br/></div><div>private void backtrack(List&lt;List&lt;Integer&gt;&gt; <b>list</b> , List&lt;Integer&gt; <b>tempList</b>, int [] <b>nums</b>, int <b>start</b>){</div><div>    list.add(new ArrayList&lt;&gt;(tempList));</div><div>    for(int i = start; i &lt; nums.length; i++){</div><div>        tempList.<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>add</b></span>(nums[i]);</div><div>        backtrack(list, tempList, nums, i + 1);</div><div>        tempList.<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>remove</b></span>(tempList.size() - 1);</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div>自己的方法写一遍DFS</div><div><br/></div><div>version1 ： 非递归</div><div>组合共 2 ^ n 种 正好可以用二进制来取</div><div>bit manipulation : 怎样选中一位</div><div>先排序保证输出的顺序</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div>    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {</div><div>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div>        if (nums == null) {</div><div>            return result;</div><div>        }</div><div>        <span style="color: rgb(255, 0, 0);">Arrays.sort(nums);</span></div><div>        for (int i = 0; i &lt; (1 &lt;&lt; nums.length); i++) {</div><div>            List&lt;Integer&gt; subset = new ArrayList&lt;Integer&gt;();</div><div>            for (int j = 0; j &lt; nums.length; j++) {</div><div>                if (<span style="color: rgb(255, 0, 0);">(i &amp; (1 &lt;&lt; j)) != 0</span>) {</div><div>                    subset.add(nums[j]);</div><div>                }</div><div>            }</div><div>            result.add(subset);</div><div>        }</div><div>        return result;</div><div>    }</div><div>}</div></div><div><br/></div><div>version2： recursive</div><div><b>回溯法</b>，就是DFS，按照顺序可以避免重复</div><div>程序一直往下走，一直到走不动</div><div><br/></div><div>思考的时候不能按照递归的顺序想，这道题应该这么想：</div><div>我分别找所有1,2,3开头的集合，横向看</div><div>1下面再是1,2开头，1,3开头</div><div><b><font color="#FF0000">递归三要素</font></b></div><div><span style="color: rgb(255, 0, 0);">递归树</span></div><div><br/></div><div><img src="78. Subsets_files/Image.png" type="image/png" style="height:auto;" width="686"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div style="margin-left:40px;">  public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] num) {</div><div style="margin-left:80px;">  ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div style="margin-left:80px;">  if(num == null || num.length == 0) {</div><div style="margin-left:80px;">  return result;</div><div style="margin-left:40px;">      }</div><div style="margin-left:80px;">  ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div style="margin-left:80px;">//要求是增序</div><div style="margin-left:80px;">  <span style="color: rgb(255, 0, 0);">Arrays.sort(num);</span>  </div><div style="margin-left:80px;">  subsetsHelper(<span style="color: rgb(209, 0, 255);">result</span>, list, num, <span style="color: rgb(209, 0, 255);">0</span>);</div><div style="margin-left:80px;"><br/></div><div style="margin-left:80px;">  return result;</div><div style="margin-left:80px;">}</div><div><br/></div><div>     //1.递归的定义：把以subset开头的所有子集都放到result里面</div><div>     //</div><div>     private <span style="color: rgb(255, 70, 53);">void</span> subsetsHelper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result,</div><div style="margin-left:40px;">                            ArrayList&lt;Integer&gt; list,</div><div style="margin-left:40px;">                            int[] num, <span style="color: rgb(209, 0, 255);">int pos</span>) {</div><div style="margin-left:40px;">//3. 什么时候是答案/什么时候退出递归</div><div style="margin-left:40px;">//要new一下再放进去，只是加入reference，list会一直变得，要把当前状态放进去</div><div style="margin-left:40px;">  result.add(<span style="color: rgb(255, 0, 0);">new ArrayList&lt;Integer&gt;(list)</span>);</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">//2.如何变为更小的问题</div><div style="margin-left:40px;">  for (int i = <span style="color: rgb(209, 0, 255);">pos</span>; i &lt; num.length; i++) {</div><div style="margin-left:40px;">     //尝试寻找以subset + (num[i])开头的所有子集</div><div style="margin-left:80px;">  <span style="color: rgb(255, 0, 0);">list</span>.add(num[i]);</div><div style="margin-left:80px;">  subsetsHelper(result, list, num, i + 1);</div><div style="margin-left:80px;">//当上面这句话结束的时候，意味着，以subset +(nums[i])开头的都找完了</div><div style="margin-left:80px;">  <span style="color: rgb(255, 0, 0);">list.remove(list.size() - 1);</span></div><div style="margin-left:80px;">  }</div><div style="margin-left:40px;">    }</div><div>}</div></div><div><br/></div></span>
</div></body></html> 