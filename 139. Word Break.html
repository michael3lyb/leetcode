<html>
<head>
  <title>139. Word Break</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (en-US, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1037"/>
<h1>139. Word Break</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>Created:</b></td><td><i>7/23/2016 11:22 PM</i></td></tr>
<tr><td><b>Updated:</b></td><td><i>1/12/2017 3:09 PM</i></td></tr>
<tr><td><b>Tags:</b></td><td><i>#, *, Dynamic Programming, leetcode tag, Medium</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><a href="https://leetcode.com/problems/word-break/">https://leetcode.com/problems/word-break/</a></div><div><br/></div><div>思路：</div><div>state:f[i]表示前i个字符能否被完美切分</div><div>function:f[i] = OR(f[j], j&lt;i,j+1 ~ i是一个词典中的单词)</div><div>initialize: f[0] = true</div><div>answer: f[s.length()]</div><div>     注意：切分位置的枚举-&gt;单词长度枚举</div><div>     <span style="color: rgb(255, 0, 0);">O(NL)</span>,N:字符串长度，L：最长的单词的长度</div><div><br/></div><div><br/></div><div>只要想好上述的四个过程一定可以得到答案，但一般都不是最佳的，在这个基础上可以优化时间和空间</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">my answer</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div>    public boolean wordBreak(String s, Set&lt;String&gt; wordDict) {</div><div>        int n = s.length();</div><div>        int m = wordDict.size();</div><div>        boolean[] f = new boolean[n + 1];</div><div>        f[0] = true;</div><div>        for (int i = 1; i &lt;= n; i++) {</div><div>            for (int j = 0; j &lt; i; j++) {</div><div>                if (<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">f[j] &amp;&amp; wordDict.contains(s.substring(j, i))</span>) {</div><div>                    f[i] = true;</div><div>                    break;</div><div>                }</div><div>            }</div><div>        }</div><div>        return f[n];</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">best now</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>public class Solution {</div><div>    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {</div><div>        int n = s.length();</div><div>        int <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">maxLen</span> = 0;</div><div>        int <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">minLen</span> = Integer.MAX_VALUE;</div><div>        for (String word : wordDict) {</div><div>            minLen = Math.min(minLen, word.length());</div><div>            maxLen = Math.max(maxLen, word.length());</div><div>        }</div><div>        boolean[] dp = new boolean[n + 1];</div><div>        dp[0] = true;</div><div>        for (int i = 0; i &lt; n; i++) {</div><div>            for (<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">int len = minLen; len &lt;= maxLen &amp;&amp; i + len &lt;= n; len++</span>) {</div><div>                if (<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">wordDict.contains(s.substring(i, i + len)) &amp;&amp; dp[i]</span>) {</div><div>                    dp[i + len] = true;</div><div>                }</div><div>                if (dp[n]) return true;</div><div>            }</div><div>        }</div><div>        return dp[n];</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">最佳</span>  2ms</div><div>//和jiuzhang的唯一区别就是用了minLength，但用了反而变慢了，奇怪</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div>    public boolean wordBreak(String s, Set&lt;String&gt; wordDict) {</div><div>        int n = s.length();</div><div>        boolean[] canWordBreak = new boolean[n + 1];</div><div>        int minLength = Integer.MAX_VALUE;</div><div>        int maxLength = Integer.MIN_VALUE;</div><div>        for(String str : wordDict) {</div><div>            //调整后减少为2ms</div><div>            <span style="color: rgb(255, 0, 0);">int length = str.length(); //length()是函数，重复调用会增加时间</span></div><div>            minLength = Math.min(minLength, length);</div><div>            maxLength = Math.max(maxLength, length);</div><div>        }</div><div>        canWordBreak[0] = true;</div><div>        for(int i = minLength; i &lt;= n; i++) {       </div><div>              for(int j = i - 1; j &gt;= 0 &amp;&amp; j &gt;= i - maxLength; j--) {</div><div>                if(canWordBreak[j] &amp;&amp; <span style="color: rgb(255, 0, 0);">wordDict.contains</span>(s.substring(j, i))) {</div><div>                    canWordBreak[i] = true;</div><div>                    break;</div><div>                }</div><div>            }</div><div>        }</div><div>        return canWordBreak[n];</div><div>    }</div><div>}</div></div><div><br/></div><div><br/></div><div>//2ms 不够简洁</div><div>//jiuzhang solution</div><div>leetcode</div><div>maxLength = 4</div><div><br/></div><div>i = 5</div><div>        //这个比较是没用的，因为最小的长度是4，而c是1</div><div style="margin-left:40px;">lastWordLength = 1</div><div style="margin-left:40px;">canSegment[4] == true</div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">substring[4,5] = c</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);"><br/></span></div><div style="margin-left:40px;">lastWordLength = 2</div><div style="margin-left:40px;">canSegment[3] == false</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">lastWordLength = 5</div><div style="margin-left:40px;"><br/></div><div><span style="color: rgb(255, 0, 0);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">public class Solution {<br/>
    private int <span style="color: rgb(255, 0, 0);">getMaxLength</span>(Set&lt;String&gt; dict) {<br/>
        int maxLength = 0;<br/>
        for (String word : dict) {<br/>
            maxLength = Math.max(maxLength, word.length());<br/>
        }<br/>
        return maxLength;<br/>
    }<br/><br/></span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    public boolean wordBreak(String s,</span> <span style="color: rgb(255, 0, 0);">Set</span><span style="color: rgb(51, 51, 51);">&lt;String&gt; dict) {</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        int maxLength = getMaxLength(dict);</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        //boolean的默认类型是false</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        boolean[] canSegment = new boolean[s.length() + 1];<br/><br/>
        canSegment[0] = true;<br/>
        for (int i = 1; i <span style="color: rgb(255, 0, 0);">&lt;=</span> s.length(); i++) {<br/>
            canSegment[i] = false;</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            for (int lastWordLength = 1;</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        //这条限制的原因是：如果</span></span>substring的长度超过最长的dict中的word的话那一定找不到，如果去掉这句话也可以通过，时间变为5ms</div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                    lastWordLength &lt;= <span style="color: rgb(255, 0, 0);">maxLength</span> <span style="color: rgb(255, 0, 0);">&amp;&amp; lastWordLength &lt;= i</span>;<br/>
                    lastWordLength++) {<br/>
                if (!canSegment[i - lastWordLength]) {<br/>
                    continue;<br/>
                }<br/>
                String word = s.<span style="color: rgb(255, 0, 0);">substring</span>(i - lastWordLength, i);<br/>
                if (dict.contains(word)) {<br/>
                    canSegment[i] = true;<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/><br/>
        return canSegment[s.length()];</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>12ms</div><div>leetcode</div><div>i = 5</div><div>j = 0 leetc</div><div>j = 1 eetc</div><div>j = 2 etc</div><div>j = 3 tc </div><div>j= 4 c</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div>    public boolean wordBreak(String s, Set&lt;String&gt; dict) {      </div><div>        boolean[] f = new boolean[s.length() + 1];     </div><div>        f[0] = true;</div><div>        //version 1</div><div>        for(int i = 1; i &lt;= s.length(); i++){<br/>
            for(int j = 0; j &lt; i; j++){<br/>
                if(<span style="color: rgb(255, 0, 0);">f[j] &amp;&amp;</span> dict.contains(s.substring(j, i))){<br/>
                    f[i] = true;<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
       <br/>
        return f[s.length()];<br/>
    }<br/>
}</div></div><div>faster: 8ms</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.148438);"><div>public class Solution {</div><div>    public boolean wordBreak(String s, Set&lt;String&gt; dict) {</div><div>        boolean[] f = new boolean[s.length() + 1];</div><div>        f[0] = true;</div><div>        //version 2</div><div>        for(int i = 1; i &lt;= s.length(); i++){</div><div>            for(String str: dict){</div><div>                if(str.length() &lt;= i){</div><div>                    if(f[i - str.length()]){</div><div>                        if(s.substring(i-str.length(), i).equals(str)){</div><div>                            f[i] = true;</div><div>                            break;</div><div>                        }</div><div>                    }</div><div>                }</div><div>            }</div><div>        }</div><div><br/></div><div>        return f[s.length()];</div><div>    }</div><div>}<br/></div></div><div><br/></div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></div></span>
</div></body></html> 